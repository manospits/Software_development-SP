#include "intlist.h"
#include "struct_list.h"
#include "hash.h"
#include "index.h"
#include "error.h"
#include <stdio.h>

int hash_function(void *data,void *size)
{
    return (*(uint32_t *)data) % (*(int*)size);
}

#test intlist
    phead list;
    phead sorted_list;
    int i,j,k;
    for(i=0;i<3;i++){
        fail_unless((list=cr_list())!=NULL);
        fail_unless((sorted_list=cr_list())!=NULL);
        for(j=0;j<1000;j++){
            fail_unless(insert(list,j)==OK_SUCCESS);
            fail_unless(insert_sorted(sorted_list,j)==OK_SUCCESS);
            fail_unless(peek(list)==j);
        }
        fail_unless(get_size(list)==1000);
        fail_unless(get_size(sorted_list)==1000);
        for(k=0;k<1100;k++){
            if(k<1000){
                fail_unless(in(list,k));
                fail_unless(ins(sorted_list,k));
            }
            else{
                fail_unless(!in(list,k));
                fail_unless(!ins(sorted_list,k));
            }
        }
        fail_unless(ds_list(list)==OK_SUCCESS);
        fail_unless(ds_list(sorted_list)==OK_SUCCESS);
    }
    puts("testing intlist finished");
#test struct_list
    stphead list;
    stphead sorted_list;
    int i,j,k;
    for(i=0;i<3;i++){
        fail_unless((list=st_cr_list())!=NULL);
        fail_unless((sorted_list=st_cr_list())!=NULL);
        for(j=0;j<1000;j++){
            fail_unless(st_insert(list,j,j,i)==OK_SUCCESS);
            fail_unless(st_insert_sorted(sorted_list,j,j,i)==OK_SUCCESS);
            fail_unless(st_peek(list)==j);
        }
        fail_unless(st_get_size(list)==1000);
        fail_unless(st_get_size(sorted_list)==1000);
        for(k=0;k<1100;k++){
            if(k<1000){
                fail_unless(st_in(list,k));
                fail_unless(st_ins(sorted_list,k));
                fail_unless(st_get_expanded(list,k)==i);
                fail_unless(st_get_expanded(sorted_list,k)==i);
                fail_unless(st_set_expanded(list,k,i+1)==OK_SUCCESS);
                fail_unless(st_set_expanded(sorted_list,k,i+1)==OK_SUCCESS);
                fail_unless(st_get_expanded(list,k)==i+1);
                fail_unless(st_get_expanded(sorted_list,k)==i+1);
            }
            else{
                fail_unless(!st_in(list,k));
                fail_unless(!st_ins(sorted_list,k));
            }
        }
        fail_unless(st_ds_list(list)==OK_SUCCESS);
        fail_unless(st_ds_list(sorted_list)==OK_SUCCESS);
    }
    puts("testing structlist finished");
#test hash
    phash hash;
    phash sorted_hash;
    int i,j,k;
    for(i=0;i<3;i++){
        fail_unless((hash=create_hashtable(HASHTABLE_SIZE,hash_function,0))!=NULL);
        fail_unless((sorted_hash=create_hashtable(HASHTABLE_SIZE,hash_function,1))!=NULL);
        for(j=0;j<1000;j++){
            fail_unless(h_insert(hash,j,j,i)==OK_SUCCESS);
            fail_unless(h_insert(sorted_hash,j,j,i)==OK_SUCCESS);
        }
        for(k=0;k<1100;k++){
            if(k<1000){
                fail_unless(in_hash(hash,k));
                fail_unless(in_hash(sorted_hash,k));
                fail_unless(ret_expanded(hash,k)==i);
                fail_unless(ret_expanded(sorted_hash,k)==i);
                fail_unless(set_expanded(hash,k,i+1)==OK_SUCCESS);
                fail_unless(set_expanded(sorted_hash,k,i+1)==OK_SUCCESS);
                fail_unless(ret_expanded(hash,k)==i+1);
                fail_unless(ret_expanded(sorted_hash,k)==i+1);

            }
            else{
                fail_unless(!in_hash(hash,k));
                fail_unless(!in_hash(sorted_hash,k));
            }
        }
        fail_unless(ds_hash(hash)==OK_SUCCESS);
        fail_unless(ds_hash(sorted_hash)==OK_SUCCESS);
    }
    puts("testing hashtable finished");

#test test_serial
    Index_ptr index;
    int i,j;
    fail_unless((index=createNodeIndex())!=NULL);
    for(i=0;i<1000;i++){
        fail_unless(insertNode(index,i)==OK_SUCCESS);
        for(j=0;j<100;j++){
            if(j%2==0)
                fail_unless(add_edge(index,i,i+j)==OK_SUCCESS);
        }
    }
    for(i=0;i<1000;i++)
        for(j=0;j<100;j++){
            if(j%2==0)
                fail_unless(edge_exists(index,i,i+j)==1);
            else
                fail_unless(edge_exists(index,i,i+j)==0);
        }
    fail_unless(destroyNodeIndex(index)==OK_SUCCESS);
    puts("test with 1000 serial inserts and 100 neighbors finished ");
#test test_step10
    Index_ptr index;
    int i,j,start;
    fail_unless((index=createNodeIndex())!=NULL);
    for(start=0;start<10;start++){
        for(i=start;i<1000;i+=10){
            fail_unless(insertNode(index,i)==OK_SUCCESS);
            for(j=0;j<100;j++){
                if(j%2==0)
                    fail_unless(add_edge(index,i,i+j)==OK_SUCCESS);
            }
        }
    }
    for(start=0;start<10;start++){
        for(i=start;i<1000;i+=10)
            for(j=0;j<100;j++){
                if(j%2==0)
                    fail_unless(edge_exists(index,i,i+j)==1);
                else
                    fail_unless(edge_exists(index,i,i+j)==0);
            }
    }
    fail_unless(destroyNodeIndex(index)==OK_SUCCESS);
    puts("test with 1000 inserts step 10 and 100 neighbors finished ");
